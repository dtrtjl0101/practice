<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EbookFileService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">chaekit</a> &gt; <a href="index.source.html" class="el_package">qwerty.chaekit.service.ebook</a> &gt; <span class="el_source">EbookFileService.java</span></div><h1>EbookFileService.java</h1><pre class="source lang-java linenums">package qwerty.chaekit.service.ebook;

import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import qwerty.chaekit.domain.ebook.Ebook;
import qwerty.chaekit.domain.ebook.repository.EbookRepository;
import qwerty.chaekit.domain.ebook.request.EbookRequest;
import qwerty.chaekit.domain.ebook.request.EbookRequestRepository;
import qwerty.chaekit.domain.ebook.request.EbookRequestStatus;
import qwerty.chaekit.domain.member.publisher.PublisherProfile;
import qwerty.chaekit.domain.member.user.UserProfile;
import qwerty.chaekit.dto.ebook.request.EbookRequestFetchResponse;
import qwerty.chaekit.dto.ebook.request.EbookRequestRejectRequest;
import qwerty.chaekit.dto.ebook.upload.EbookDownloadResponse;
import qwerty.chaekit.dto.ebook.upload.EbookPostRequest;
import qwerty.chaekit.dto.ebook.upload.EbookPostResponse;
import qwerty.chaekit.dto.page.PageResponse;
import qwerty.chaekit.global.enums.ErrorCode;
import qwerty.chaekit.global.exception.BadRequestException;
import qwerty.chaekit.global.exception.ForbiddenException;
import qwerty.chaekit.global.security.resolver.PublisherToken;
import qwerty.chaekit.global.security.resolver.UserToken;
import qwerty.chaekit.mapper.EbookRequestMapper;
import qwerty.chaekit.service.util.EmailNotificationService;
import qwerty.chaekit.service.util.EntityFinder;
import qwerty.chaekit.service.util.FileService;

import java.util.List;

@Service
@Transactional
@RequiredArgsConstructor
public class EbookFileService {
    private final EbookRepository ebookRepository;
    private final EbookPolicy ebookPolicy;
    private final FileService fileService;
    private final EntityFinder entityFinder;
    private final EbookRequestRepository ebookRequestRepository;
    private final EbookRequestMapper ebookRequestMapper;
    private final EmailNotificationService emailNotificationService;

    @Transactional
    public EbookPostResponse uploadEbook(PublisherToken publisherToken, EbookPostRequest request) {
<span class="fc" id="L46">        PublisherProfile publisher = entityFinder.findPublisher(publisherToken.publisherId());</span>

<span class="fc bfc" id="L48" title="All 2 branches covered.">        if(!publisher.isApproved()) {</span>
<span class="fc" id="L49">            throw new ForbiddenException(ErrorCode.PUBLISHER_NOT_APPROVED);</span>
        }

<span class="fc" id="L52">        String fileKey = fileService.uploadEbook(request.file());</span>
<span class="fc" id="L53">        String coverImageKey = fileService.uploadEbookCoverImageIfPresent(request.coverImageFile());</span>
<span class="fc" id="L54">        String coverImageURL = fileService.convertToPublicImageURL(coverImageKey);</span>

<span class="fc" id="L56">        EbookRequest ebookRequest = EbookRequest.builder()</span>
<span class="fc" id="L57">                .title(request.title())</span>
<span class="fc" id="L58">                .author(request.author())</span>
<span class="fc" id="L59">                .description(request.description())</span>
<span class="fc" id="L60">                .size(request.file().getSize())</span>
<span class="fc" id="L61">                .price(request.price())</span>
<span class="fc" id="L62">                .fileKey(fileKey)</span>
<span class="fc" id="L63">                .coverImageKey(coverImageKey)</span>
<span class="fc" id="L64">                .publisher(publisher)</span>
<span class="fc" id="L65">                .build();</span>
<span class="fc" id="L66">        EbookRequest saved = ebookRequestRepository.save(ebookRequest);</span>

<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        if (publisher.isAdmin()) {</span>
<span class="nc" id="L69">            approveRequest(saved);</span>
        }

<span class="fc" id="L72">        return EbookPostResponse.of(saved.toEbook(), ebookRequest.getId(), coverImageURL);</span>
    }

    @Transactional
    public EbookDownloadResponse getPresignedEbookUrlForUser(UserToken userToken, Long ebookId) {
<span class="fc" id="L77">        UserProfile user = entityFinder.findUser(userToken.userId());</span>
<span class="fc" id="L78">        Ebook ebook = entityFinder.findEbook(ebookId);</span>

<span class="fc" id="L80">        ebookPolicy.assertEBookPurchased(user, ebook);</span>
        
<span class="fc" id="L82">        String ebookFileKey = ebook.getFileKey();</span>
<span class="fc" id="L83">        String downloadUrl = fileService.getEbookDownloadUrl(ebookFileKey);</span>

<span class="fc" id="L85">        return EbookDownloadResponse.of(downloadUrl);</span>
    }
    
    @Transactional
    public EbookDownloadResponse getPresignedEbookUrlForPublisher(PublisherToken publisherToken, Long ebookId) {
<span class="fc" id="L90">        PublisherProfile publisher = entityFinder.findPublisher(publisherToken.publisherId());</span>
<span class="fc" id="L91">        Ebook ebook = entityFinder.findEbook(ebookId);</span>

<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (!ebook.isOwnedBy(publisher)) {</span>
<span class="nc" id="L94">            throw new ForbiddenException(ErrorCode.EBOOK_NOT_OWNED);</span>
        }

<span class="fc" id="L97">        String ebookFileKey = ebook.getFileKey();</span>
<span class="fc" id="L98">        String downloadUrl = fileService.getEbookDownloadUrl(ebookFileKey);</span>

<span class="fc" id="L100">        return EbookDownloadResponse.of(downloadUrl);</span>
    }
    
    @Transactional
    public EbookDownloadResponse getPresignedTempEbookUrlForPublisher(PublisherToken publisherToken, Long ebookRequestId) {
<span class="fc" id="L105">        PublisherProfile publisher = entityFinder.findPublisher(publisherToken.publisherId());</span>
<span class="fc" id="L106">        EbookRequest ebookRequest = entityFinder.findEbookRequest(ebookRequestId);</span>

<span class="pc bpc" id="L108" title="1 of 4 branches missed.">        if (!ebookRequest.isRequestedBy(publisher) &amp;&amp; publisher.isNotAdmin()) {</span>
<span class="fc" id="L109">            throw new ForbiddenException(ErrorCode.EBOOK_REQUEST_NOT_YOURS);</span>
        }

<span class="fc" id="L112">        String ebookFileKey = ebookRequest.getFileKey();</span>
<span class="fc" id="L113">        String downloadUrl = fileService.getEbookDownloadUrl(ebookFileKey);</span>

<span class="fc" id="L115">        return EbookDownloadResponse.of(downloadUrl);</span>
    }
    
    @Transactional
    public void approveEbookByAdmin(PublisherToken publisherToken, Long requestId) {
<span class="fc" id="L120">        PublisherProfile publisher = entityFinder.findPublisher(publisherToken.publisherId());</span>
<span class="fc" id="L121">        EbookRequest request = entityFinder.findEbookRequest(requestId);</span>
        
<span class="fc" id="L123">        assertAdmin(publisher);</span>
<span class="fc" id="L124">        assertRequestIsPending(request);</span>

<span class="fc" id="L126">        approveRequest(request);</span>
<span class="fc" id="L127">    }</span>

    @Transactional
    public void rejectEbookByAdmin(PublisherToken publisherToken, Long requestId, EbookRequestRejectRequest requestBody) {
<span class="fc" id="L131">        PublisherProfile publisher = entityFinder.findPublisher(publisherToken.publisherId());</span>
<span class="fc" id="L132">        EbookRequest request = entityFinder.findEbookRequest(requestId);</span>
        
<span class="fc" id="L134">        assertAdmin(publisher);</span>
<span class="fc" id="L135">        assertRequestIsPending(request);</span>
        
<span class="fc" id="L137">        request.reject(requestBody.reason());</span>
<span class="fc" id="L138">        emailNotificationService.sendEbookRejectionEmail(publisher.getMember().getEmail(), requestBody.reason());</span>
<span class="fc" id="L139">    }</span>

    @Transactional(readOnly = true)
    public PageResponse&lt;EbookRequestFetchResponse&gt; getEbookRequests(
            PublisherToken publisherToken, Pageable pageable
    ) {
<span class="fc" id="L145">        PublisherProfile publisher = entityFinder.findPublisher(publisherToken.publisherId());</span>
        
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (publisher.isNotAdmin()) {</span>
<span class="fc" id="L148">            return PageResponse.of(</span>
<span class="fc" id="L149">                    ebookRequestRepository.findByPublisher(publisher, pageable)</span>
<span class="fc" id="L150">                            .map(ebookRequestMapper::toFetchResponse)</span>
            );
        }

<span class="nc" id="L154">        return PageResponse.of(</span>
<span class="nc" id="L155">                ebookRequestRepository.findByStatusIn(</span>
<span class="nc" id="L156">                        List.of(</span>
                                EbookRequestStatus.PENDING, 
                                EbookRequestStatus.REJECTED
                        ), pageable
<span class="nc" id="L160">                        ).map(ebookRequestMapper::toFetchResponse)</span>
        );
    }

    private void assertAdmin(PublisherProfile publisher) {
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (publisher.isNotAdmin()) {</span>
<span class="fc" id="L166">            throw new ForbiddenException(ErrorCode.ONLY_ADMIN);</span>
        }
<span class="fc" id="L168">    }</span>

    private void assertRequestIsPending(EbookRequest request) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (request.isNotPending()) {</span>
<span class="fc" id="L172">            throw new BadRequestException(ErrorCode.EBOOK_REQUEST_NOT_PENDING);</span>
        }
<span class="fc" id="L174">    }</span>

    private void approveRequest(EbookRequest request) {
<span class="fc" id="L177">        Ebook savedEbook = ebookRepository.save(request.toEbook());</span>
<span class="fc" id="L178">        request.approve(savedEbook);</span>
<span class="fc" id="L179">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>